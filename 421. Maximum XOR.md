## 421. Maximum XOR of Two Numbers in an Array
### 題目:
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

EX: 給定一序列為[2,3,5,8,10,25]，任取兩數經過 XOR 運算後為最大。

### 直觀寫法
```
class Solution(object):
    def findMaximumXOR(self, nums):
        ans = mask = 0
        for x in range(32)[::-1]:
            mask += 1 << x
            prefixSet = set()
            temp = ans | 1 << x
            for n in nums:
                if temp ^ (n & mask) in prefixSet:
                    ans = temp
                    break            
                else:
                    prefixSet.add((n & mask))
        return ans
```

### 更快的寫法：
```
class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        L = len(bin(max(nums))) - 2
        max_xor = 0
        for i in range(L)[::-1]:
            max_xor <<= 1
            curr_xor = max_xor | 1
            prefixes = {num >> i for num in nums}
            max_xor |= any(curr_xor^p in prefixes for p in prefixes)
        return max_xor
```
### 先備知識點:
1.數字在計算機中以二進位儲存。
2.數字的加(減)，其實是位數的 "平移" 與+1(-1)所組成
EX:1+1=2
step1:       | 1 |
step2: | 1 |        <<平移
step3: | 1 | | 0 |     
               ^ 補0
step4: | 1 | | 1|
               ^ +1
3.在一個數列$S$有一最大數$k$，則該數$k$的前$n$位必不小於數列$S$中任一數的前$n$位。
Ex: 
S:[2,5,6]   ,  最大數為 6
2   :   | 0 | 1 | 0 |
5   :   | 1 | 0 | 1 |
6   :   | 1 | 1 | 0 |
--> 最大數6的前兩位(11)必不小於S中任一數的前兩位(01,10,11)

4.XOR(^) 性質:
a ^ b = c
a ^ c = b
c ^ b = a

### 算法蓋念:
有一數列$S$與任一數$k$($k$不在$S$中)，若$k$皆大於$S$中任一數，則$k$前$n$位必不小於$S$中任一數前$n$位。**(阿就是最大數$k$的前$n$位也一定最大啦!!)**
->若有一數$k$，在符合運算規則下(本題為xor)盡可能使最高位為1，從最高位依次往低位數運算，則可得到最大數$k$。

### 流程:
step1:
十進位         二進位
2   :   | 0 | 0 | 0 | 1 | 0 |
3   :   | 0 | 0 | 0 | 1 | 1 |
5   :   | 0 | 0 | 1 | 0 | 1 |
8   :   | 0 | 1 | 0 | 0 | 0 |
10  :   | 0 | 1 | 0 | 1 | 0 |
25  :   | 1 | 1 | 0 | 0 | 1 |
temp
16  :   | 1 | 0 | 0 | 0 | 0 |
          ^
step2:
十進位         二進位
2   :   | 0 | 0 | 0 | 1 | 0 |
3   :   | 0 | 0 | 0 | 1 | 1 |
5   :   | 0 | 0 | 1 | 0 | 1 |
~~8   :   | 0 | 1 | 0 | 0 | 0 |~~(11 xor 01 = 10,在數列中找不到前兩位為 10 的數)
~~10  :   | 0 | 1 | 0 | 1 | 0 |~~(11 xor 01 = 10,在數列中找不到前兩位為 10 的數)
25  :   | 1 | 1 | 0 | 0 | 1 |
temp
24  :   | 1 | 1 | 0 | 0 | 0 |
              ^
step3:
十進位         二進位
~~2   :   | 0 | 0 | 0 | 1 | 0 |~~(111 xor 000 = 111,在數列中找不到前兩位為 111 的數)
~~3   :   | 0 | 0 | 0 | 1 | 1 |~~(111 xor 000 = 111,在數列中找不到前兩位為 111 的數)
5   :   | 0 | 0 | 1 | 0 | 1 |
25  :   | 1 | 1 | 0 | 0 | 1 |
temp
28  :   | 1 | 1 | 1 | 0 | 0 |
                  ^
                  
step4:
十進位         二進位
5   :   | 0 | 0 | 1 | 0 | 1 |
25  :   | 1 | 1 | 0 | 0 | 1 |
temp
28  :   | 1 | 1 | 1 | 0 | 0 |(數列$S$中第四位全為0，故 0 xor 0 = 0)
                      ^
step5:
十進位         二進位
5   :   | 0 | 0 | 1 | 0 | 1 |
25  :   | 1 | 1 | 0 | 0 | 1 |
temp
28  :   | 1 | 1 | 1 | 0 | 0 |(數列$S$中第四位全為1，故 1 xor 1 = 0)
                          ^
得最大數$k=28$
