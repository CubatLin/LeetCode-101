# 算法筆記
  
  這裡是自己對算法的直觀理解，若要進一步探討算法的詳細作法與內容，推薦臺師大資工系所建立的網站：http://web.ntnu.edu.tw/~algo/index.html
  
  如果有從頭啃完的童鞋們，還請留下聯絡方式，小弟會找你要簽名的。
  
## 算法基礎的直觀理解

  小弟目前對算法可以理解成兩個部分 - "依資料結構設計的算法" 和 "依數學問題特性而設計的算法"，掌握這兩個概念，學習算法應該會少走些冤枉路，畢竟算法的概念就兩個:
  
  1. 算過的不要再算。
  2. 能計算一次的就不要計算兩次。

### 1. 依資料結構設計算法

  **"很多問題不需計算，只需一個好的儲存方式..."**
  
  資料結構是演算法的基石，算法有很大一部份不是"怎麼算答案"，而是"怎麼找答案"。
  
  - 記憶法: 
  
    Ex:對序列 S 排序。

    ```
      //技數排序法
      for-loop: 陣列 A 紀錄 S 中元素 s 的個數。
      for-loop: 陣列 A 中依統計資訊提取 s (由小到大)。
    ```
  
### 2. 依數學問題特行設計算法
  
  **"凡是能用數字表示的問題，都是數學問題。"**

  - 迭代法:

    **不斷利用目前求得的數值，再求得新數值。**

    Ex:字串變整數

    ```
    A = "26962869"
    sum = 0
    for-loop: 
      sum += sum * 10 + A[i]
    ```
    
  - 枚舉法(注意!不是窮舉法):
  
    兩步驟:

    1. 枚舉一個數、物件、變數...等，與目標做比較。

    2. 是 -> 輸出；不是 -> 回到 1.

    一不注意就會變成窮舉法。

    Ex:尋找陣列 A 之中的數字 a ，A 陣列已經由小到大排序。

    ```
    while len(A)>0:
      if A[mid]<a: A = A 的左半部
      elif A[mid]>a: A = A 的右半部
      else: 輸出 A[mid]

    ```

  - 遞迴法:
  
    **大問題由小問題組成，小問題的解法又跟大問題一樣。**

    Ex:輾轉相除法

    ```
    int gcd(int a, int b)
    {
        if (b == 0): return a;
        else: return gcd(b, a % b);
    }
    ```
  
  - 遞推法:
  
    **小問題是大問題的一部份，依序處理小問題，就解決了大問題。**
  
    Ex:字串變整數
    
    ```
    A = "26962869"
    for-loop: 
      sum += A[i] * pow(10,len(A)-i-1)
    ```
