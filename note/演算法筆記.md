## 資料結構

### 1. Linked List
- 想像他是一個分散儲存記憶體的非連續列表，關聯是用pointer做出來
- 只能從頭尾開始遍歷，所以查詢單一元素是O(n)
- 一般都說在資料修改(插入/刪除)時是O(1)，前提是你已經知道元素位置(有reference)，不知道的話一樣要先查詢到元素位置O(n)+資料修改(插入/刪除)時是O(1)
- 資料串流處理（stream processing）中，你維護一個滑動視窗（sliding window）像是抓客戶最新的三筆資料做inference，需要不斷刪掉最舊資料、在中間插入新資料。如果用 array，每次中間插入/刪除都要搬移大量元素，成本高。Linked list 直接改 pointer，已知位置時 O(1)


### 2. Array
- 想像他是連續儲存在記憶體，所以可以用index去對每個元素做access，快取記憶體也會比較快 > 查詢時間是O(1)，但一樣如果你不知道他在哪，一樣要O(n)做查詢
- 資料修改(插入/刪除)時是O(n)，因為連續記憶體要整個做移動
- 其實 Python 的 list 不是 linked list，底層還是「單一連續的動態陣列」，只是它會自動擴容而已。來拆開解釋：
    - Dynamic Array 的概念:
    底層有一塊連續記憶體陣列，大小可能比實際元素多一些（預留空間）。當 append 超過容量時：分配一塊更大的連續陣列（通常會比原本大 1.5~2 倍）> 把舊陣列的資料複製到新陣列 > 釋放舊陣列 > 這就是「動態陣列」的特性 → 平均 append O(1) 攤銷
    - 為什麼不是 linked list: 
    Linked list 每個元素有一個「指標/next」，各節點可以分散在記憶體任意位置。Python list 內部元素是連續的 C 指標陣列（PyObject* array），所以可以用索引直接跳 → O(1) 存取。如果是 linked list，你就沒辦法 O(1) 索引存取，只能從頭走到尾 → O(n)。
    - 擴容 vs linked list: Dynamic array 的擴容雖然需要複製，但這是一次性操作，之後就可以繼續用同一塊連續空間。Linked list 沒有複製問題，但每個節點都有指標開銷，記憶體不連續，快取效率差。


### 3. Stack & queue
- stack就是桶子，放進去的數據都是會沉在最下面、要拿從筒子上面拿
    - 可以用array做，但一開始開的記憶體大小要夠大
    - 用linked list做不用擔心記憶體問題，但快取不如array
    - python的list是array, 把list頭當作桶子底, append當作慢慢stack
    - 在 Python 中通常用 list 實作 stack，因為 append/pop 尾端操作就是 O(1)。
    - Linked list 用得少，除非要經常在頭部 push/pop（Python list 在頭部 pop(0) O(n)）

- queue是筒子破洞，放進去的數據在最下面，但拿從下面拿
    - 用array做的話，如果是拿最下面，要把最下面的元素移除O(1)然後把所有元素都往後挪一格O(n)
    - 用linked list
    - Python 標準庫提供 collections.deque（雙端佇列），底層就是雙向 linked list + block。
    - 使用 deque 來實作 queue，頭尾操作都 O(1)，比 list pop(0) 高效。
- Python 的 list 既可以像 stack 一樣在尾端高效操作，也保有 array（動態陣列） 的優勢——已知索引的查詢是 O(1)
    - 實作stack可以直接用list
    - 實作queue可以用collections.deque, 底層就是雙向 linked list + block（固定大小的連續陣列塊


### 4. Hash Table
- 就是key:value, 用來查詢使用


### 5. Heap(以min表達)
```
        50
       /  \
     30    40
    / \   / \
  10  20 35  25
```
- 拿來執行priority queue, 數據從最上層＆最左側進行填入
- 子節點的數字一定要比父節點的數字大, 當父節點的數字比子節點大時, 數字要交換
- 取數字時會從跟節點開始取 > 然後把順序最後(最右下)的數字移到最上方 > 將連接的子節點較小數與根節點對調


### 6. Binary Search Tree(超不熟)
```
      8
     / \
    3   10
   / \    \
  1   6    14
     / \   /
    4   7 13
```
- 一個節點最多左右兩個子節點, 
- 節點上的數字都會大於所連結左側的數字(如果有子樹：不只純左側, 包含往下子樹的右側)
- 節點上的數字都會小於連結右邊的數字
- 新增節點的話, 就是按照左右的規則百
- 刪除節點的話, 把刪除節點往下左側的子數，裡面最大的節點取代刪除節點的位置, 保持節點比左側子節點還大的特性
- 直覺想就是O(log2n的)時間複雜度



## 排序演算法

### 1. bubble sort
- 有n個數, 從最右側的數字開始for loop, 與相鄰左側的數比大小, 把比較小的往左移 > 每一個iteration都可以把嘴小的數字移到左邊
- Edge case: 一個全部是倒序的array做bubble sort > 時間複雜度應該是O(n+n-1+n-2+....+1)= O([n+1]*n/2) > O(n^2)
 
### 2. selection sort
- 搜尋數列中最小的數，並把它放到左邊 > 每一個iteration都可以把嘴小的數字移到左邊
- Edge case: 一個全部是倒序的array做selection sort > 時間複雜度應該是O(n+n-1+n-2+....+1)= O([n+1]*n/2) > O(n^2)

### 3. insertion sort
```
[5, 1, 3, 10] > [1, 5, 3, 10] > > [1, 3, 5, 10]
 *               *  *                 *  *
```
- 從左到右做for loop, 每次都把當前面的數字與左側的數列做比較, 並做數字交換, 
- 邏輯上就是: 在每一個for loop完成都確認左邊的數列是有排序的 > 接下來我只要將當前的數字加入這個有排序的左側數列 > 左側數列排序大小的特性不變 > 這樣for loop 跑完, 數列就是有序的
- Edge case: 倒序的array, 外層要先for每個數字O(n) , 接下來都跟左側的比大小O(1+2+...+n) > O(n^2) > 會是O(n^3)?
    - 原本思路:
    ```
    外層 for 跑 O(n) 次
    內層比較插入跑 1+2+⋯+𝑛
    1+2+⋯+n ≈ O(n²) 次
    所以：O(n) × O(n²) = O(n³) ❌
    ```
    - 正確思路:
    ```
    外層 for：i = 1 到 n-1
    每一輪 外層 for 迴圈，內層比較次數：i
    總次數 = 1+2+3+⋯+(n−1)
    這個加總公式等於：
    𝑛(𝑛−1)/2
    也就是 O(n²)。
    ```

### 4. heap sort
- heap結構的特性就是最大值/最小值分別在最上面/最下面, 保持這個原則, 讓(根節點與最後的元素兌換 > 並把剩下的資料做heap), 重複以上步驟就可以
- 做heap sort前要先確保資料是合規的heap
- 比較跟Heap差異
    | 步驟     | **Build Heap**                     | **Heap Sort**                                                               |
    | ------ | ---------------------------------- | --------------------------------------------------------------------------- |
    | **目標** | 把任意陣列調整成符合 Heap 規則                 | 利用 Heap 特性完成排序                                                              |
    | **流程** | 自底向上（Bottom-Up）對每個父節點做 `sift-down` | 1. **Build Heap**<br>2. 把根節點和最後節點交換<br>3. 對剩餘元素 `Heapify`<br>4. 重複直到剩 1 個元素 |
    | **結果** | 陣列變成 Heap 形式（最大值/最小值在根節點）          | 陣列變成排序好的結果                                                                  |
- 範例（輸入 `[1, 3, 5, 2]`）:
    1. Step 1 — 建立 Max Heap  
    從最後一個有子節點的父節點開始（index = ⌊(n-2)/2⌋）  
    - index=1 (值=3)：左子=2（值=2） → `3 ≥ 2` → ✅ OK  
    - index=0 (值=1)：左子=3，右子=5 → 最大子是 `5` → 交換  
    - 陣列狀態：`[5, 3, 1, 2]`  
    ✅ 現在它是一個合法的 **Max Heap**。  

    2. Step 2 — 取最大值放到正確位置  
    - 最大值在根（`5`），跟最後一個元素（`2`）交換 → 陣列：`[2, 3, 1, 5]`  
    - 現在最後位置的 `5` 已經在正確位置，不用管它。  
    - 對前面 n-1 個元素（`[2, 3, 1]`）做 **Heapify**：  
    - index=0 (值=2)：左子=3，右子=1 → 最大子=`3` → 交換 → 陣列：`[3, 2, 1, 5]`  

    3. Step 3 — 繼續取最大值  
    - 根（`3`）和最後一個元素（`1`）交換 → 陣列：`[1, 2, 3, 5]`  
    - 對前 n-2 個元素（`[1, 2]`）做 **Heapify**：  
    - index=0 (值=1)：左子=2 → 最大子=`2` → 交換 → 陣列：`[2, 1, 3, 5]`  

    4. Step 4 — 最後一次  
    - 根（`2`）和最後一個元素（`1`）交換 → 陣列：`[1, 2, 3, 5]`  
    - 只剩一個元素，結束。  

    5. 最終結果  
    - 陣列：`[1, 2, 3, 5]`  
    已經是升序排序。  

    6. 時間複雜度  
    - **Build Heap**：O(n)  
    - **每次取最大值 + Heapify**：O(log n)，共 n 次 → O(n log n)  
    - **總計**：O(n log n)


### 5. merge sort
- 分割 (Divide):
    - 把一個數列不斷分割，直到每個子數列只剩下 一個元素（無限切下去 → 最小的數列就是單一元素）。
    - 單一元素的子數列，因為本身就是「已排序」。

- 合併 (Conquer):
    - 從最小的數列開始，兩兩比較：
    - 比較兩個子數列的最前面元素（因為它們已經各自排序）。
    - 把小的放進結果陣列，再移動該子數列的指標，繼續比較。
    - 一直合併上去，直到最後得到完整的排序結果。

- 想成一開始就已經分割好了，每一層都是O(n)的複雜度、而有log2(n)層 > 時間複雜度就是O(n * log2(n))


### 6. quick sort（遞迴）
- 任選一個數當作基準值，把比基準值小的往左放、比基準值大的往右放，接下來就可以確定基準值左邊都比基準值小、右邊較大
- 這時候再把左邊當成一個數列、右邊當作一個數列，重複做quick sort，做到底後就可以得到一個正確的排序
- (錯)空間複雜度不用創造新的空間 / 時間複雜度是O(n + n-1 + n-2+.....) = O((n+1)*n/2)約O(n^2) 
- 最壞情況：每一次都只拿到最大數、這樣層數會是n > 時間複雜度會是O(n^2)
- 正常情況：拿到的數可以切出左跟右、這樣層數會是log2(n) > 時間複雜度會是O(n*log2(n))


## 搜尋目標數

### binary search
- 只適合用在已排序好的數列（左小右大）
- 隨選一個數，比目標數小就往左邊的數列切一半繼續找
- 直覺想有log2(n)層，時間複雜度是log2(n)


## 圖形搜尋(Graph)

### BFS/DFS
### Bellman-Ford Algorithm
- 思路(n個點、e條邊)：
    - 我讓每個節點的值代表「目前找到的最短距離」 
    - 不斷嘗試用邊來更新，看看能不能縮短距離 
    - 每一輪都要更新e條邊
    - 更新幾輪不知道？因為最短路徑最多經過n個點(n-1條邊) / 如果有一輪沒有更新任何邊，那就可以early stop
    - 所以時間複雜度是O((n-1)*e)
- 適用加權有向圖，准許負權重、可以偵測負環(如果起點能到負環、這樣最小路徑不存在)
- 初始值是起點=0、其它點 = +∞
- 更新方式：對每條邊 (u,v,w) 做 dist[v] = min(dist[v], dist[u] + w)。重複恰好 V−1 輪（V=節點數），因為V個點的路徑最多用到V-1條邊
- 停止條件：實務上可用「某一輪沒更新就提早停」，但標準流程仍要再做第 V 輪掃描；若還能更新，代表存在負環。只寫「不再更新就結束」而不檢查負環是不完整的。
- 精神是當起點到該點的路徑都是最短時，從起點走到終點就可用hash map方式計算
- 當我試著讓dist[v] = min(dist[v], dist[u]+w)讓每個邊都是當前的最短路徑，此時只要確認停止條件就好
- 不是以bfs的方式更新疊加起點到該點每條邊的權重：
    - 因為bfs是以層的方式往外擴展，但Bellman-Ford是透過
    - bfs可以看成權重都是1的bellman-ford
- monk:
```
    # n = 節點數, adj = adjacency_list 格式: {u: [(v, w), ...]}
    # s = 起點

    dist = {v: INF for v in adj}
    dist[s] = 0
    pred = {v: None for v in adj}

    # 最多 n-1 輪
    for i in range(n-1):
        for u in adj:                # 對每個點
            for v, w in adj[u]:      # 對每條邊 (u,v,w)
                if dist[u] + w < dist[v]:
                    dist[v] = dist[u] + w
                    pred[v] = u      # 紀錄前驅 (用來重建路徑)

    # 負環檢測 (第 n 輪)
    for u in adj:
        for v, w in adj[u]:
            if dist[u] + w < dist[v]:
                print("有負權環")
```
- 動態規劃: 用當前小問題的最佳解，逐步推導出大問題的最佳解
### Dijkstra Algorithm
- dp的部分：在每一階段都是「從起點到該點」的最短路徑 > 最後就可以得起點到終點的路徑 
- 初始值是起點=0、其它點 = +∞
- 以深度的方式往下走，更新起點到該點的權重 ❌ 這裡要改：Dijkstra 不是「深度」(DFS/BFS) 的概念。
    - ✅ 應該是：「從當前確定的最短節點，更新它所有鄰居的距離」。
- 每走一步就檢查目前所有深度哪個節點的累積步伐權重值最小，從那個點開始往下走 ⭕ 幾乎正確！
    - ✅ 但要更精準：應該是「在所有還沒被確定的節點中，挑選目前 dist 最小的節點，把它確定，然後鬆弛它的鄰居」。
- 時間複雜度：n個點, e個邊 > 直覺會是n-1個點都要走e
- 實作的時候注意動態規劃的細節！

### A* Algorithm
- 可以想為變種的Dijkstra Algorithm, 一樣是走深度, 但是讓離終點過遠的路徑不做搜尋
- 多的input為點/邊權重/heuristic人為估計
- 也因此需要事先人主觀給予邊的「試探權重」，但怎麼給才合理？
- 常見 heuristic 範例:
```
    網格地圖（上下左右移動）：
        - Manhattan distance（∣𝑥1−𝑥2∣+∣𝑦1−𝑦2∣∣x1−x2∣+∣y1−y2∣）
    平面連線（可斜線移動）：
        - Euclidean distance（直線距離）
    棋盤移動（像國際象棋國王走法）：
        - Chebyshev distance（max(∣𝑑𝑥∣,∣𝑑𝑦∣) max(∣dx∣,∣dy∣)）
    實際應用
        - 地圖導航：h 可用「直線距離 / 平均車速」當作預估時間
        - 遊戲 AI：h 可用「到目的地的最短步數」或「估計戰術成本」
```
- 這個演算法如果heuristic設計太高估試探邊權重，是有可能找不到最短路徑的，但實務上人其實需要搜尋的快、可以接受稍微高估的非最短路徑(google map)


## 加密演算法
### 為何要加密
- 網路傳遞可能被竊聽 > 用加密來解決
- 電子欺騙: 遇到偽裝的agent > 用訊息鑑別碼來解決
- 資訊傳遞被篡改 > 用訊息鑑別碼、數位簽章來解決
- 抵賴: 假裝沒有收到post > 用數位簽章來解決

### Hash
- input一個string, 無論sting長短, 輸出的長度不變
- input一個string, 一樣的sting輸出結果會一樣
- input 2個不同string, 有很低的機率可能產生相同hash value > hash collision

### 共用金鑰密碼
- 透過私鑰進行加密解密、現在多用AES
- 除了文本要傳送、更可能金曜也要傳送、都有可能被竊取

### 公開金鑰密碼
- 數據接收者製作公開鑰匙、解密用另一種私密金鑰匙然後私人保管不傳出
- 公開鑰匙發佈給資料提供者，

